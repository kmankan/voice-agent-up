Key Concept
We highly recommended you to read this page before start using Elysia.
Although Elysia is a simple library, it has some key concepts that you need to understand to use it effectively.

This page covers most important concepts of Elysia that you should to know.

Everything is a component
Every Elysia instance is a component.

A component is a plugin that could plug into other instances.

It could be a router, a store, a service, or anything else.


import { Elysia } from 'elysia'

const store = new Elysia()
	.state({ visitor: 0 })

const router = new Elysia()
	.use(store)
	.get('/increase', ({ store }) => store.visitor++)

const app = new Elysia()
	.use(router)
	.get('/', ({ store }) => store)
	.listen(3000)
This force you to break down your application into small pieces, making it to add or remove features easily.

Learn more about this in plugin.

Scope
By default, event/life-cycle in each instance is isolated from each other.


import { Elysia } from 'elysia'

const ip = new Elysia()
	.derive(({ server, request }) => ({
		ip: server?.requestIP(request)
	}))
	.get('/ip', ({ ip }) => ip)

const server = new Elysia()
	.use(ip)
	.get('/ip', ({ ip }) => ip)
Property 'ip' does not exist on type '{ body: unknown; query: Record<string, string | undefined>; params: {}; headers: Record<string, string | undefined>; cookie: Record<string, Cookie<string | undefined>>; ... 8 more ...; error: <const Code extends number | keyof StatusMap, const T = Code extends 100 | ... 58 more ... | 511 ? { ...; }[Code] : Code>(cod...'.
	.listen(3000)
In this example, the ip property is only share in it's own instance but not in the server instance.

To share the lifecycle, in our case, an ip property with server instance, we need to explicitly says it could be shared.


import { Elysia } from 'elysia'

const ip = new Elysia()
	.derive(
		{ as: 'global' }, 
		({ server, request }) => ({
			ip: server?.requestIP(request)
		})
	)
	.get('/ip', ({ ip }) => ip)

const server = new Elysia()
	.use(ip)
	.get('/ip', ({ ip }) => ip)
	.listen(3000)
In this example, ip property is shared between ip and server instance because we define it as global.

This force you to think about the scope of each property preventing you from accidentally sharing the property between instances.

Learn more about this in scope.

Method Chaining
Elysia code should always use method chaining.

As Elysia type system is complex, every methods in Elysia returns a new type reference.

This is important to ensure type integrity and inference.


import { Elysia } from 'elysia'

new Elysia()
    .state('build', 1)
    // Store is strictly typed
    .get('/', ({ store: { build } }) => build)
    .listen(3000)
In the code above state returns a new ElysiaInstance type, adding a build type.

❌ Don't: Use Elysia without method chaining
Without using method chaining, Elysia doesn't save these new types, leading to no type inference.


import { Elysia } from 'elysia'

const app = new Elysia()

app.state('build', 1)

app.get('/', ({ store: { build } }) => build)
Property 'build' does not exist on type '{}'.

app.listen(3000)
We recommend to always use method chaining to provide an accurate type inference.

Dependency
By default, each instance will be re-execute everytime it's applied to another instance.

This can cause a duplication of the same method being applied multiple times but some methods should be called once like lifecycle or routes.

To prevent lifecycle methods from being duplicated, we can add an unique identifier to the instance.


import { Elysia } from 'elysia'

const ip = new Elysia({ name: 'ip' })
	.derive(
		{ as: 'global' },
		({ server, request }) => ({
			ip: server?.requestIP(request)
		})
	)
	.get('/ip', ({ ip }) => ip)

const router1 = new Elysia()
	.use(ip)
	.get('/ip-1', ({ ip }) => ip)

const router2 = new Elysia()
	.use(ip)
	.get('/ip-2', ({ ip }) => ip)

const server = new Elysia()
	.use(router1)
	.use(router2)
This will prevent the ip property from being call multiple time by applying deduplication using an unique name.

Once name is provided, the instance will become a singleton. Allowing Elysia to apply plugin deduplication.

Allowing us to reuse the same instance multiple time without performance penalty.

This force you to think about the dependency of each instance, allowing for easily applying migration or refactoring.

Learn more about this in plugin deduplication.

Type Inference
Elysia has a complex type system that allows you to infer types from the instance.


import { Elysia, t } from 'elysia'

const app = new Elysia()
	.post('/', ({ body }) => body, {




		body: t.Object({
			name: t.String()
		})
	})
If possible, always use an inline function to provide an accurate type inference.

If you need to apply a separate function, eg. MVC's controller pattern. It's recommended to destructure properties from inline function to prevent unnecessary type inference.


import { Elysia, t } from 'elysia'

abstract class Controller {
	static greet({ name }: { name: string }) {
		return 'hello ' + name
	}
}

const app = new Elysia()
	.post('/', ({ body }) => Controller.greet(body), {
		body: t.Object({
			name: t.String()
		})
	})
Learn more about this in Best practice: MVC Controller.

Edit this page on GitHub
Last updated: 01/02/2025, 22:07

Pager
Previous page
Tutorial
Next page
Table of Content
build: number
body: {
    name: string;
}


Routing
Web servers use the request's path and HTTP method to look up the correct resource, refers as "routing".

We can define a route by calling a method named after HTTP verbs, passing a path and a function to execute when matched.


import { Elysia } from 'elysia'

new Elysia()
    .get('/', 'hello')
    .get('/hi', 'hi')
    .listen(3000)
We can access the web server by going to http://localhost:3000

By default, web browsers will send a GET method when visiting a page.

localhost
/
GET

hello
TIP

Using an interactive browser above, hover on a blue highlight area to see difference result between each path

Path type
Path in Elysia can be grouped into 3 types:

static paths - static string to locate the resource
dynamic paths - segment can be any value
wildcards - path until a specific point can be anything
You can use all of the path types together to compose a behavior for your web server.

The priorities are as follows:

static paths
dynamic paths
wildcards
If the path is resolved as the static wild dynamic path is presented, Elysia will resolve the static path rather than the dynamic path


import { Elysia } from 'elysia'

new Elysia()
    .get('/id/1', 'static path')
    .get('/id/:id', 'dynamic path')
    .get('/id/*', 'wildcard path')
    .listen(3000)
localhost
/id/1
GET

static path
Here the server will respond as follows:

Path	Response
/id/1	static path
/id/2	dynamic path
/id/2/a	wildcard path
Static Path
A path or pathname is an identifier to locate resources of a server.


http://localhost:/path/page
Elysia uses the path and method to look up the correct resource.

URL Representation
A path starts after the origin. Prefix with / and ends before search query (?)

We can categorize the URL and path as follows:

URL	Path
http://site.com/	/
http://site.com/hello	/hello
http://site.com/hello/world	/hello/world
http://site.com/hello?name=salt	/hello
http://site.com/hello#title	/hello
TIP

If the path is not specified, the browser and web server will treat the path as '/' as a default value.

Elysia will look up each request for route and response using handler function.

Dynamic path
URLs can be both static and dynamic.

Static paths are hardcoded strings that can be used to locate resources of the server, while dynamic paths match some part and captures the value to extract extra information.

For instance, we can extract the user ID from the pathname. For example:


import { Elysia } from 'elysia'

new Elysia()
    .get('/id/:id', ({ params: { id } }) => id)
    .listen(3000)

Here dynamic path is created with /id/:id which tells Elysia to match any path up until /id. What comes after that is then stored as params object.

localhost
/id/1
GET

1
When requested, the server should return the response as follows:

Path	Response
/id/1	1
/id/123	123
/id/anything	anything
/id/anything?name=salt	anything
/id	Not Found
/id/anything/rest	Not Found
Dynamic paths are great to include things like IDs, which then can be used later.

We refer to the named variable path as path parameter or params for short.

Segment
URL segments are each path that is composed into a full path.

Segments are separated by /.Representation of URL segments

Path parameters in Elysia are represented by prefixing a segment with ':' followed by a name.Representation of path parameter

Path parameters allow Elysia to capture a specific segment of a URL.

The named path parameter will then be stored in Context.params.

Route	Path	Params
/id/:id	/id/1	id=1
/id/:id	/id/hi	id=hi
/id/:name	/id/hi	name=hi
Multiple path parameters
You can have as many path parameters as you like, which will then be stored into a params object.


import { Elysia } from 'elysia'

new Elysia()
    .get('/id/:id', ({ params: { id } }) => id)
    .get('/id/:id/:name', ({ params: { id, name } }) => id + ' ' + name)
    .listen(3000)


localhost
/id/1
GET

1
The server will respond as follows:

Path	Response
/id/1	1
/id/123	123
/id/anything	anything
/id/anything?name=salt	anything
/id	Not Found
/id/anything/rest	anything rest
Optional path parameters
Sometime we might want a static and dynamic path to resolve the same handler.

We can make a path parameter optional by adding a question mark ? after the parameter name.


import { Elysia } from 'elysia'

new Elysia()
    .get('/id/:id?', ({ params: { id } }) => `id ${id}`)
    .listen(3000)

localhost
/id
GET

id: undefined
The server will respond as follows:

Path	Response
/id	id undefined
/id/1	id 1
Wildcards
Dynamic paths allow capturing certain segments of the URL.

However, when you need a value of the path to be more dynamic and want to capture the rest of the URL segment, a wildcard can be used.

Wildcards can capture the value after segment regardless of amount by using "*".


import { Elysia } from 'elysia'

new Elysia()
    .get('/id/*', ({ params }) => params['*'])
    .listen(3000)

localhost
/id/1
GET

1
In this case the server will respond as follows:

Path	Response
/id/1	1
/id/123	123
/id/anything	anything
/id/anything?name=salt	anything
/id	Not Found
/id/anything/rest	anything/rest
Wildcards are useful for capturing a path until a specific point.

TIP

You can use a wildcard with a path parameter.

HTTP Verb
HTTP defines a set of request methods to indicate the desired action to be performed for a given resource

There are several HTTP verbs, but the most common ones are:

GET
Requests using GET should only retrieve data.

POST
Submits a payload to the specified resource, often causing state change or side effect.

PUT
Replaces all current representations of the target resource using the request's payload.

PATCH
Applies partial modifications to a resource.

DELETE
Deletes the specified resource.

To handle each of the different verbs, Elysia has a built-in API for several HTTP verbs by default, similar to Elysia.get


import { Elysia } from 'elysia'

new Elysia()
    .get('/', 'hello')
    .post('/hi', 'hi')
    .listen(3000)
localhost
/
GET

hello
Elysia HTTP methods accepts the following parameters:

path: Pathname
function: Function to respond to the client
hook: Additional metadata
You can read more about the HTTP methods on HTTP Request Methods.

Custom Method
We can accept custom HTTP Methods with Elysia.route.


import { Elysia } from 'elysia'

const app = new Elysia()
    .get('/get', 'hello')
    .post('/post', 'hi')
    .route('M-SEARCH', '/m-search', 'connect') 
    .listen(3000)
localhost
/get
GET

hello
Elysia.route accepts the following:

method: HTTP Verb
path: Pathname
function: Function to response to the client
hook: Additional metadata
When navigating to each method, you should see the results as the following:

Path	Method	Result
/	GET	hello
/	POST	hi
/	M-SEARCH	connect
TIP

Based on RFC 7231, HTTP Verb is case-sensitive.

It's recommended to use the UPPERCASE convention for defining a custom HTTP Verb with Elysia.

Elysia.all
Elysia provides an Elysia.all for handling any HTTP method for a specified path using the same API like Elysia.get and Elysia.post


import { Elysia } from 'elysia'

new Elysia()
    .all('/', 'hi')
    .listen(3000)
localhost
/
GET

hi
Any HTTP method that matches the path, will be handled as follows:

Path	Method	Result
/	GET	hi
/	POST	hi
/	DELETE	hi
Handle
Most developers use REST clients like Postman, Insomnia or Hoppscotch to test their API.

However, Elysia can be programmatically test using Elysia.handle.


import { Elysia } from 'elysia'

const app = new Elysia()
    .get('/', 'hello')
    .post('/hi', 'hi')
    .listen(3000)

app.handle(new Request('http://localhost/')).then(console.log)
Elysia.handle is a function to process an actual request sent to the server.

TIP

Unlike unit test's mock, you can expect it to behave like an actual request sent to the server.

But also useful for simulating or creating unit tests.

404
If no path matches the defined routes, Elysia will pass the request to error life cycle before returning a "NOT_FOUND" with an HTTP status of 404.

We can handle a custom 404 error by returning a value from error life cycle like this:


import { Elysia } from 'elysia'

new Elysia()
    .get('/', 'hi')
    .onError(({ code }) => {
        if (code === 'NOT_FOUND') {
            return 'Route not found :('
        }
    })
    .listen(3000)
localhost
/
GET

hello
When navigating to your web server, you should see the result as follows:

Path	Method	Result
/	GET	hi
/	POST	Route not found :(
/hi	GET	Route not found :(
You can learn more about life cycle and error handling in Life Cycle Events and Error Handling.

TIP

HTTP Status is used to indicate the type of response. By default if everything is correct, the server will return a '200 OK' status code (If a route matches and there is no error, Elysia will return 200 as default)

If the server fails to find any route to handle, like in this case, then the server shall return a '404 NOT FOUND' status code.

Group
When creating a web server, you would often have multiple routes sharing the same prefix:


import { Elysia } from 'elysia'

new Elysia()
    .post('/user/sign-in', 'Sign in')
    .post('/user/sign-up', 'Sign up')
    .post('/user/profile', 'Profile')
    .listen(3000)
localhost
/user/sign-in
POST

Sign in
This can be improved with Elysia.group, allowing us to apply prefixes to multiple routes at the same time by grouping them together:


import { Elysia } from 'elysia'

new Elysia()
    .group('/user', (app) =>
        app
            .post('/sign-in', 'Sign in')
            .post('/sign-up', 'Sign up')
            .post('/profile', 'Profile')
    )
    .listen(3000)
localhost
/user/sign-in
POST

Sign in
This code behaves the same as our first example and should be structured as follows:

Path	Result
/user/sign-in	Sign in
/user/sign-up	Sign up
/user/profile	Profile
.group() can also accept an optional guard parameter to reduce boilerplate of using groups and guards together:


import { Elysia, t } from 'elysia'

new Elysia()
    .group(
        '/user',
        {
            body: t.Literal('Rikuhachima Aru')
        },
        (app) => app
            .post('/sign-in', 'Sign in')
            .post('/sign-up', 'Sign up')
            .post('/profile', 'Profile')
    )
    .listen(3000)
You may find more information about grouped guards in scope.

Prefix
We can separate a group into a separate plugin instance to reduce nesting by providing a prefix to the constructor.


import { Elysia } from 'elysia'

const users = new Elysia({ prefix: '/user' })
    .post('/sign-in', 'Sign in')
    .post('/sign-up', 'Sign up')
    .post('/profile', 'Profile')

new Elysia()
    .use(users)
    .get('/', 'hello world')
    .listen(3000)
localhost
/
GET

hello world
Edit this page on GitHub
Last updated: 01/02/2025, 22:07

Pager
Previous page
Table of Content
Next page
Handler
params: {
    id: string;
}
params: {
    id: string;
    name: string;
}
params: {
    id?: string | undefined;
}
params: {
    "*": string;
}

Handler
Handler is a function that responds to the request for each route.

Accepting request information and returning a response to the client.

Altenatively, handler is also known as a Controller in other frameworks.


import { Elysia } from 'elysia'

new Elysia()
    // the function `() => 'hello world'` is a handler
    .get('/', () => 'hello world')
    .listen(3000)
Handler maybe a literal value, and can be inlined.


import { Elysia, file } from 'elysia'

new Elysia()
    .get('/', 'Hello Elysia')
    .get('/video', file('kyuukurarin.mp4'))
    .listen(3000)
Using an inline value always returns the same value which is useful to optimize performance for static resource like file.

This allows Elysia to compile the response ahead of time to optimize performance.

TIP

Providing an inline value is not a cache.

Static Resource value, headers and status can be mutate dynamically using lifecycle.

Context
Context contains a request information which unique for each request, and is not shared except for store (global mutable state).


import { Elysia } from 'elysia'

new Elysia()
	.get('/', (context) => context.path)
            // ^ This is a context
Context can be only retrieve in a route handler, consists of:

path - Pathname of the request
body - HTTP message, form or file upload.
query - Query String, include additional parameters for search query as JavaScript Object. (Query is extracted from a value after pathname starting from '?' question mark sign)
params - Elysia's path parameters parsed as JavaScript object
headers - HTTP Header, additional information about the request like User-Agent, Content-Type, Cache Hint.
request - Web Standard Request
redirect - A function to redirect a response
store - A global mutable store for Elysia instance
cookie - A global mutable signal store for interacting with Cookie (including get/set)
set - Property to apply to Response:
status - HTTP status, defaults to 200 if not set.
headers - Response headers
redirect - Response as a path to redirect to
error - A function to return custom status code
server - Bun server instance
Set
set is a mutable property that form a response accessible via Context.set.

set.status - Set custom status code
set.headers - Append custom headers
set.redirect - Append redirect

import { Elysia } from 'elysia'

new Elysia()
	.get('/', ({ set, error }) => {
		set.headers = { 'X-Teapot': 'true' }

		return error(418, 'I am a teapot')
	})
	.listen(3000)
status
We can return a custom status code by using either:

error function (recommended)
set.status (legacy)

import { Elysia } from 'elysia'

new Elysia()
	.get('/error', ({ error }) => error(418, 'I am a teapot'))
	.get('/set.status', ({ set }) => {
		set.status = 418
		return 'I am a teapot'
	})
	.listen(3000)
set.error
A dedicated error function for returning status code with response.


import { Elysia } from 'elysia'

new Elysia()
    .get('/', ({ error }) => error(418, "Kirifuji Nagisa"))
    .listen(3000)
localhost
/
GET

Kirifuji Nagisa
It's recommend to use error inside main handler as it has better inference:

allows TypeScript to check if a return value is correctly type to response schema
autocompletion for type narrowing base on status code
type narrowing for error handling using End-to-end type safety (Eden)
set.status
Set a default status code if not provided.

It's recommended to use this in a plugin that only needs to return a specific status code while allowing the user to return a custom value. For example, HTTP 201/206 or 403/405, etc.


import { Elysia } from 'elysia'

new Elysia()
    .onBeforeHandle(({ set }) => {
        set.status = 418

        return 'Kirifuji Nagisa'
    })
    .get('/', () => 'hi')
    .listen(3000)
Unlike error function, set.status cannot infer the return value type, therefore it can't check if the return value is correctly type to response schema.

TIP

HTTP Status indicates the type of response. If the route handler is executed successfully without error, Elysia will return the status code 200.

You can also set a status code using the common name of the status code instead of using a number.


// @errors 2322
import { Elysia } from 'elysia'

new Elysia()
    .get('/', ({ set }) => {
        set.status

        return 'Kirifuji Nagisa'
    })
    .listen(3000)
set.headers
Allowing us to append or delete a response headers represent as Object.


import { Elysia } from 'elysia'

new Elysia()
    .get('/', ({ set }) => {
        set.headers['x-powered-by'] = 'Elysia'

        return 'a mimir'
    })
    .listen(3000)
WARNING

The names of headers should be lowercase to force case-sensitivity consistency for HTTP headers and auto-completion, eg. use set-cookie rather than Set-Cookie.

redirect
Redirect a request to another resource.


import { Elysia } from 'elysia'

new Elysia()
    .get('/', ({ redirect }) => {
        return redirect('https://youtu.be/whpVWVWBW4U?&t=8')
    })
    .get('/custom-status', ({ redirect }) => {
        // You can also set custom status to redirect
        return redirect('https://youtu.be/whpVWVWBW4U?&t=8', 302)
    })
    .listen(3000)
When using redirect, returned value is not required and will be ignored. As response will be from another resource.

Server
Server instance is accessible via Context.server to interact with the server.

Server could be nullable as it could be running in a different environment (test).

If server is running (allocating) using Bun, server will be available (not null).


import { Elysia } from 'elysia'

new Elysia()
	.get('/port', ({ server }) => {
		return server?.port
	})
	.listen(3000)
Request IP
We can get request IP by using server.requestIP method


import { Elysia } from 'elysia'

new Elysia()
	.get('/ip', ({ server, request }) => {
		return server?.requestIP(request)
	})
	.listen(3000)
Response
Elysia is built on top of Web Standard Request/Response.

To comply with the Web Standard, a value returned from route handler will be mapped into a Response by Elysia.

Letting you focus on business logic rather than boilerplate code.


import { Elysia } from 'elysia'

new Elysia()
    // Equivalent to "new Response('hi')"
    .get('/', () => 'hi')
    .listen(3000)
If you prefer an explicit Response class, Elysia also handles that automatically.


import { Elysia } from 'elysia'

new Elysia()
    .get('/', () => new Response('hi'))
    .listen(3000)
TIP

Using a primitive value or Response has near identical performance (+- 0.1%), so pick the one you prefer, regardless of performance.

Formdata
We may return a FormData by using returning form utility directly from the handler.


import { Elysia, form, file } from 'elysia'

new Elysia()
	.get('/', () => form({
		name: 'Tea Party',
		images: [file('nagi.web'), file('mika.webp')]
	}))
	.listen(3000)
This pattern is useful if even need to return a file or multipart form data.

Return a single file
Or alternatively, you can return a single file by returning file directly without form.


import { Elysia, file } from 'elysia'

new Elysia()
	.get('/', file('nagi.web'))
	.listen(3000)
Handle
As Elysia is built on top of Web Standard Request, we can programmatically test it using Elysia.handle.


import { Elysia } from 'elysia'

const app = new Elysia()
    .get('/', () => 'hello')
    .post('/hi', () => 'hi')
    .listen(3000)

app.handle(new Request('http://localhost/')).then(console.log)
Elysia.handle is a function to process an actual request sent to the server.

TIP

Unlike unit test's mock, you can expect it to behave like an actual request sent to the server.

But also useful for simulating or creating unit tests.

Stream
To return a response streaming out of the box by using a generator function with yield keyword.


import { Elysia } from 'elysia'

const app = new Elysia()
	.get('/ok', function* () {
		yield 1
		yield 2
		yield 3
	})
This this example, we may stream a response by using yield keyword.

Set headers
Elysia will defers returning response headers until the first chunk is yielded.

This allows us to set headers before the response is streamed.


import { Elysia } from 'elysia'

const app = new Elysia()
	.get('/ok', function* ({ set }) {
		// This will set headers
		set.headers['x-name'] = 'Elysia'
		yield 1
		yield 2

		// This will do nothing
		set.headers['x-id'] = '1'
		yield 3
	})
Once the first chunk is yielded, Elysia will send the headers and the first chunk in the same response.

Setting headers after the first chunk is yielded will do nothing.

Conditional Stream
If the response is returned without yield, Elysia will automatically convert stream to normal response instead.


import { Elysia } from 'elysia'

const app = new Elysia()
	.get('/ok', function* () {
		if (Math.random() > 0.5) return 'ok'

		yield 1
		yield 2
		yield 3
	})
This allows us to conditionally stream a response or return a normal response if necessary.

Abort
While streaming a response, it's common that request may be cancelled before the response is fully streamed.

Elysia will automatically stop the generator function when the request is cancelled.

Eden
Eden will will interpret a stream response as AsyncGenerator allowing us to use for await loop to consume the stream.


import { Elysia } from 'elysia'
import { treaty } from '@elysiajs/eden'

const app = new Elysia()
	.get('/ok', function* () {
		yield 1
		yield 2
		yield 3
	})

const { data, error } = await treaty(app).ok.get()
if (error) throw error

for await (const chunk of data)
	console.log(chunk)
Extending context
As Elysia only provides essential information, we can customize Context for our specific need for instance:

extracting user ID as variable
inject a common pattern repository
add a database connection
We may extend Elysia's context by using the following APIs to customize the Context:

state - a global mutable state
decorate - additional property assigned to Context
derive / resolve - create a new value from existing property
When to extend context
You should only extend context when:

A property is a global mutable state, and shared across multiple routes using state
A property is associated with a request or response using decorate
A property is derived from an existing property using derive / resolve
Otherwise, we recommend defining a value or function separately than extending the context.

TIP

It's recommended to assign properties related to request and response, or frequently used functions to Context for separation of concerns.

State
State is a global mutable object or state shared across the Elysia app.

Once state is called, value will be added to store property once at call time, and can be used in handler.


import { Elysia } from 'elysia'

new Elysia()
    .state('version', 1)
    .get('/a', ({ store: { version } }) => version)
    .get('/b', ({ store }) => store)
    .get('/c', () => 'still ok')
    .listen(3000)
localhost
/a
GET

1
When to use
When you need to share a primitive mutable value across multiple routes
If you want to use a non-primitive or a wrapper value or class that mutate an internal state, use decorate instead.
Key takeaway
store is a representation of a single-source-of-truth global mutable object for the entire Elysia app.
state is a function to assign an initial value to store, which could be mutated later.
Make sure to assign a value before using it in a handler.

import { Elysia } from 'elysia'

new Elysia()
    // ❌ TypeError: counter doesn't exist in store
    .get('/error', ({ store }) => store.counter)
Property 'counter' does not exist on type '{}'.
    .state('counter', 0)
    // ✅ Because we assigned a counter before, we can now access it
    .get('/', ({ store }) => store.counter)
localhost
/error
GET

TIP

Beware that we cannot use a state value before assign.

Elysia registers state values into the store automatically without explicit type or additional TypeScript generic needed.

Decorate
decorate assigns an additional property to Context directly at call time.


import { Elysia } from 'elysia'

class Logger {
    log(value: string) {
        console.log(value)
    }
}

new Elysia()
    .decorate('logger', new Logger())
    // ✅ defined from the previous line
    .get('/', ({ logger }) => {
        logger.log('hi')

        return 'hi'
    })
When to use
A constant or readonly value object to Context
Non primitive value or class that may contain internal mutable state
Additional functions, singleton, or immutable property to all handlers.
Key takeaway
Unlike state, decorated value SHOULD NOT be mutated although it's possible
Make sure to assign a value before using it in a handler.
Derive
Retrieve values from existing properties in Context and assign new properties.

Derive assigns when request happens at transform lifecycle allowing us to "derive" (create new properties from existing properties).


import { Elysia } from 'elysia'

new Elysia()
    .derive(({ headers }) => {
        const auth = headers['authorization']

        return {
            bearer: auth?.startsWith('Bearer ') ? auth.slice(7) : null
        }
    })
    .get('/', ({ bearer }) => bearer)
localhost
/
GET

12345
Because derive is assigned once a new request starts, derive can access request properties like headers, query, body where store, and decorate can't.

When to use
Create a new property from existing properties in Context without validation or type checking
When you need to access request properties like headers, query, body without validation
Key takeaway
Unlike state and decorate instead of assign at call time, derive is assigned once a new request starts.
derive is called at transform, or before validation happens, Elysia cannot safely confirm the type of request property resulting in as unknown. If you want to assign a new value from typed request properties, you may want to use resolve instead.
Resolve
Same as derive, resolve allow us to assign a new property to context.

Resolve is called at beforeHandle lifecycle or after validation, allowing us to derive request properties safely.


import { Elysia, t } from 'elysia'

new Elysia()
	.guard({
		headers: t.Object({
			bearer: t.String({
				pattern: '^Bearer .+$'
			})
		})
	})
	.resolve(({ headers }) => {
		return {
			bearer: headers.bearer.slice(7)
		}
	})
	.get('/', ({ bearer }) => bearer)
When to use
Create a new property from existing properties in Context with type integrity (type checked)
When you need to access request properties like headers, query, body with validation
Key takeaway
resolve is called at beforeHandle, or after validation happens. Elysia can safely confirm the type of request property resulting in as typed.
Error from resolve/derive
As resolve and derive is based on transform and beforeHandle lifecycle, we can return an error from resolve and derive. If error is returned from derive, Elysia will return early exit and return the error as response.


import { Elysia } from 'elysia'

new Elysia()
    .derive(({ headers, error }) => {
        const auth = headers['authorization']

        if(!auth) return error(400)

        return {
            bearer: auth?.startsWith('Bearer ') ? auth.slice(7) : null
        }
    })
    .get('/', ({ bearer }) => bearer)
Pattern
state, decorate offers a similar APIs pattern for assigning property to Context as the following:

key-value
object
remap
Where derive can be only used with remap because it depends on existing value.

key-value
We can use state, and decorate to assign a value using a key-value pattern.


import { Elysia } from 'elysia'

class Logger {
    log(value: string) {
        console.log(value)
    }
}

new Elysia()
    .state('counter', 0)
    .decorate('logger', new Logger())
This pattern is great for readability for setting a single property.

Object
Assigning multiple properties is better contained in an object for a single assignment.


import { Elysia } from 'elysia'

new Elysia()
    .decorate({
        logger: new Logger(),
        trace: new Trace(),
        telemetry: new Telemetry()
    })
The object offers a less repetitive API for setting multiple values.

Remap
Remap is a function reassignment.

Allowing us to create a new value from existing value like renaming or removing a property.

By providing a function, and returning an entirely new object to reassign the value.


import { Elysia } from 'elysia'

new Elysia()
    .state('counter', 0)
    .state('version', 1)
    .state(({ version, ...store }) => ({
        ...store,
        elysiaVersion: 1
    }))
    // ✅ Create from state remap
    .get('/elysia-version', ({ store }) => store.elysiaVersion)
    // ❌ Excluded from state remap
    .get('/version', ({ store }) => store.version)
Property 'version' does not exist on type '{ elysiaVersion: number; counter: number; }'.
localhost
/elysia-version
GET

1
It's a good idea to use state remap to create a new initial value from the existing value.

However, it's important to note that Elysia doesn't offer reactivity from this approach, as remap only assigns an initial value.

TIP

Using remap, Elysia will treat a returned object as a new property, removing any property that is missing from the object.

Affix
To provide a smoother experience, some plugins might have a lot of property value which can be overwhelming to remap one-by-one.

The Affix function which consists of prefix and suffix, allowing us to remap all property of an instance.


import { Elysia } from 'elysia'

const setup = new Elysia({ name: 'setup' })
    .decorate({
        argon: 'a',
        boron: 'b',
        carbon: 'c'
    })

const app = new Elysia()
    .use(
        setup
            .prefix('decorator', 'setup')
    )
    .get('/', ({ setupCarbon, ...rest }) => setupCarbon)
localhost
/
GET

c
Allowing us to bulk remap a property of the plugin effortlessly, preventing the name collision of the plugin.

By default, affix will handle both runtime, type-level code automatically, remapping the property to camelCase as naming convention.

In some condition, we can also remap all property of the plugin:


import { Elysia } from 'elysia'

const setup = new Elysia({ name: 'setup' })
    .decorate({
        argon: 'a',
        boron: 'b',
        carbon: 'c'
    })

const app = new Elysia()
    .use(setup.prefix('all', 'setup')) 
    .get('/', ({ setupCarbon, ...rest }) => setupCarbon)
Reference and value
To mutate the state, it's recommended to use reference to mutate rather than using an actual value.

When accessing the property from JavaScript, if we define a primitive value from an object property as a new value, the reference is lost, the value is treated as new separate value instead.

For example:


const store = {
    counter: 0
}

store.counter++
console.log(store.counter) // ✅ 1
We can use store.counter to access and mutate the property.

However, if we define a counter as a new value


const store = {
    counter: 0
}

let counter = store.counter

counter++
console.log(store.counter) // ❌ 0
console.log(counter) // ✅ 1
Once a primitive value is redefined as a new variable, the reference "link" will be missing, causing unexpected behavior.

This can apply to store, as it's a global mutable object instead.


import { Elysia } from 'elysia'

new Elysia()
    .state('counter', 0)
    // ✅ Using reference, value is shared
    .get('/', ({ store }) => store.counter++)
    // ❌ Creating a new variable on primitive value, the link is lost
    .get('/error', ({ store: { counter } }) => counter)
localhost
/
GET

0
TypeScript
Elysia automatically type context base on various of factors like store, decorators, schema.

It's recommended to leave Elysia to type context instead of manually define one.

However, Elysia also offers some utility type to help you define a handler type.

InferContext
InferHandle
InferContext
Infer context is a utility type to help you define a context type based on Elysia instance.


import { Elysia, type InferContext } from 'elysia'

const setup = new Elysia()
	.state('a', 'a')
	.decorate('b', 'b')

type Context = InferContext<typeof setup>

const handler = ({ store }: Context) => store.a
InferHandler
Infer handler is a utility type to help you define a handler type based on Elysia instance, path, and schema.


import { Elysia, type InferHandler } from 'elysia'

const setup = new Elysia()
	.state('a', 'a')
	.decorate('b', 'b')

type Handler = InferHandler<
	// Elysia instance to based on
	typeof setup,
	// path
	'/path',
	// schema
	{
		body: string
		response: {
			200: string
		}
	}
>

const handler: Handler = ({ body }) => body

const app = new Elysia()
	.get('/', handler)
Unlike InferContext, InferHandler requires a path and schema to define a handler type and can safely ensure type safety of a return type.

Edit this page on GitHub
Last updated: 01/02/2025, 22:07

Pager
Previous page
Route
Next page
Life Cycle
status?: number | "Continue" | "Switching Protocols" | "Processing" | "Early Hints" | "OK" | "Created" | "Accepted" | "Non-Authoritative Information" | "No Content" | "Reset Content" | ... 50 more ... | undefined
store: {
    version: number;
}

Best Practice
Elysia is a pattern-agnostic framework, leaving the decision of which coding patterns to use up to you and your team.

However, there are several concern from trying to adapt an MVC pattern (Model-View-Controller) with Elysia, and found it's hard to decouple and handle types.

This page is a guide to on how to follows Elysia structure best practice combined with MVC pattern but can be adapted to any coding pattern you like.

Method Chaining
Elysia code should always use method chaining.

As Elysia type system is complex, every methods in Elysia returns a new type reference.

This is important to ensure type integrity and inference.


import { Elysia } from 'elysia'

new Elysia()
    .state('build', 1)
    // Store is strictly typed
    .get('/', ({ store: { build } }) => build)
    .listen(3000)
In the code above state returns a new ElysiaInstance type, adding a build type.

❌ Don't: Use Elysia without method chaining
Without using method chaining, Elysia doesn't save these new types, leading to no type inference.


import { Elysia } from 'elysia'

const app = new Elysia()

app.state('build', 1)

app.get('/', ({ store: { build } }) => build)
Property 'build' does not exist on type '{}'.

app.listen(3000)
We recommend to always use method chaining to provide an accurate type inference.

Controller
1 Elysia instance = 1 controller

Elysia does a lot to ensure type integrity, if you pass an entire Context type to a controller, these might be the problems:

Elysia type is complex and heavily depends on plugin and multiple level of chaining.
Hard to type, Elysia type could change at anytime, especially with decorators, and store
Type casting may lead to a loss of type integrity or an inability to ensure consistency between types and runtime code.
This makes it more challenging for Sucrose (Elysia's "kind of" compiler) to statically analyze your code
❌ Don't: Create a separate controller
Don't create a separate controller, use Elysia itself as a controller instead:


import { Elysia, t, type Context } from 'elysia'

abstract class Controller {
    static root(context: Context) {
        return Service.doStuff(context.stuff)
    }
}

// ❌ Don't
new Elysia()
    .get('/', Controller.hi)
By passing an entire Controller.method to Elysia is an equivalent of having 2 controllers passing data back and forth. It's against the design of framework and MVC pattern itself.

✅ Do: Use Elysia as a controller
Instead treat an Elysia instance as a controller itself instead.


import { Elysia } from 'elysia'
import { Service } from './service'

new Elysia()
    .get('/', ({ stuff }) => {
        Service.doStuff(stuff)
    })
Testing
You can test your controller using handle to directly call a function (and it's lifecycle)


import { Elysia } from 'elysia'
import { Service } from './service'

import { describe, it, should } from 'bun:test'

const app = new Elysia()
    .get('/', ({ stuff }) => {
        Service.doStuff(stuff)

        return 'ok'
    })

describe('Controller', () => {
	it('should work', async () => {
		const response = await app
			.handle(new Request('http://localhost/'))
			.then((x) => x.text())

		expect(response).toBe('ok')
	})
})
You may find more information about testing in Unit Test.

Service
Service is a set of utility/helper functions decoupled as a business logic to use in a module/controller, in our case, an Elysia instance.

Any technical logic that can be decoupled from controller may live inside a Service.

There're 2 types of service in Elysia:

Non-request dependent service
Request dependent service
✅ Do: Non-request dependent service
This kind of service doesn't need to access any property from the request or Context, and can be initiated as a static class same as usual MVC service pattern.


import { Elysia, t } from 'elysia'

abstract class Service {
    static fibo(number: number): number {
        if(number < 2)
            return number

        return Service.fibo(number - 1) + Service.fibo(number - 2)
    }
}

new Elysia()
    .get('/fibo', ({ body }) => {
        return Service.fibo(body)
    }, {
        body: t.Numeric()
    })
If your service doesn't need to store a property, you may use abstract class and static instead to avoid allocating class instance.

Request Dependent Service
This kind of service may require some property from the request, and should be initiated as an Elysia instance.

❌ Don't: Pass entire Context to a service
Context is a highly dynamic type that can be inferred from Elysia instance.

Do not pass an entire Context to a service, instead use object destructuring to extract what you need and pass it to the service.


import type { Context } from 'elysia'

class AuthService {
	constructor() {}

	// ❌ Don't do this
	isSignIn({ cookie: { session } }: Context) {
		if (session.value)
			return error(401)
	}
}
As Elysia type is complex, and heavily depends on plugin and multiple level of chaining, it can be challenging to manually type as it's highly dynamic.

✅ Do: Use Elysia instance as a service
We recommended to use Elysia instance as a service to ensure type integrity and inference:


import { Elysia } from 'elysia'

// ✅ Do
const AuthService = new Elysia({ name: 'Service.Auth' })
    .derive({ as: 'scoped' }, ({ cookie: { session } }) => ({
    	// This is equivalent to dependency injection
        Auth: {
            user: session.value
        }
    }))
    .macro(({ onBeforeHandle }) => ({
     	// This is declaring a service method
        isSignIn(value: boolean) {
            onBeforeHandle(({ Auth, error }) => {
                if (!Auth?.user || !Auth.user) return error(401)
            })
        }
    }))

const UserController = new Elysia()
    .use(AuthService)
    .get('/profile', ({ Auth: { user } }) => user, {
    	isSignIn: true
    })
TIP

Elysia handle plugin deduplication by default so you don't have to worry about performance, as it's going to be Singleton if you specified a "name" property.

⚠️ Infers Context from Elysia instance
In case of absolute necessity, you may infer the Context type from the Elysia instance itself:


import { Elysia, type InferContext } from 'elysia'

const setup = new Elysia()
	.state('a', 'a')
	.decorate('b', 'b')

class AuthService {
	constructor() {}

	// ✅ Do
	isSignIn({ cookie: { session } }: InferContext<typeof setup>) {
		if (session.value)
			return error(401)
	}
}
However we recommend to avoid this if possible, and use Elysia as a service instead.

You may find more about InferContext in Essential: Handler.

Model
Model or DTO (Data Transfer Object) is handle by Elysia.t (Validation).

Elysia has a validation system built-in which can infers type from your code and validate it at runtime.

❌ Don't: Declare a class instance as a model
Do not declare a class instance as a model:


// ❌ Don't
class CustomBody {
	username: string
	password: string

	constructor(username: string, password: string) {
		this.username = username
		this.password = password
	}
}

// ❌ Don't
interface ICustomBody {
	username: string
	password: string
}
✅ Do: Use Elysia's validation system
Instead of declaring a class or interface, use Elysia's validation system to define a model:


// ✅ Do
import { Elysia, t } from 'elysia'

const customBody = t.Object({
	username: t.String(),
	password: t.String()
})

// Optional if you want to get the type of the model
// Usually if we didn't use the type, as it's already inferred by Elysia
type CustomBody = typeof customBody.static



export { customBody }
We can get type of model by using typeof with .static property from the model.

Then you can use the CustomBody type to infer the type of the request body.


// ✅ Do
new Elysia()
	.post('/login', ({ body }) => {
		return body
	}, {
		body: customBody
	})
❌ Don't: Declare type separate from the model
Do not declare a type separate from the model, instead use typeof with .static property to get the type of the model.


// ❌ Don't
import { Elysia, t } from 'elysia'

const customBody = t.Object({
	username: t.String(),
	password: t.String()
})

type CustomBody = {
	username: string
	password: string
}

// ✅ Do
const customBody = t.Object({
	username: t.String(),
	password: t.String()
})

type CustomBody = typeof customBody.static
Group
You can group multiple models into a single object to make it more organized.


import { Elysia, t } from 'elysia'

export const AuthModel = {
	sign: t.Object({
		username: t.String(),
		password: t.String()
	})
}

const models = AuthModel.models
Model Injection
Though this is optional, if you are strictly following MVC pattern, you may want to inject like a service into a controller. We recommended using Elysia reference model

Using Elysia's model reference


import { Elysia, t } from 'elysia'

const customBody = t.Object({
	username: t.String(),
	password: t.String()
})

const AuthModel = new Elysia()
    .model({
        'auth.sign': customBody
    })

const models = AuthModel.models

const UserController = new Elysia({ prefix: '/auth' })
    .use(AuthModel)
    .post('/sign-in', async ({ body, cookie: { session } }) => {

        return true
    }, {
        body: 'auth.sign'
    })
This approach provide several benefits:

Allow us to name a model and provide auto-completion.
Modify schema for later usage, or perform a remap.
Show up as "models" in OpenAPI compliance client, eg. Swagger.
Improve TypeScript inference speed as model type will be cached during registration.
Reuse a plugin
It's ok to reuse plugins multiple time to provide type inference.

Elysia handle plugin deduplication automatically by default, and the performance is negligible.

To create a unique plugin, you may provide a name or optional seed to an Elysia instance.


import { Elysia } from 'elysia'

const plugin = new Elysia({ name: 'my-plugin' })
	.decorate("type", "plugin")

const app = new Elysia()
    .use(plugin)
    .use(plugin)
    .use(plugin)
    .use(plugin)
    .listen(3000)
This allows Elysia to improve performance by reusing the registered plugins instead of processing the plugin over and over again.

Edit this page on GitHub
Last updated: 01/02/2025, 22:07

Pager
Previous page
Plugin
Next page
Macro
type CustomBody = {
    username: string;
    password: string;
}
body: {
    username: string;
    password: string;
}
body: {
    username: string;
    password: string;
}
